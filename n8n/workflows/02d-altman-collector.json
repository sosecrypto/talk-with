{
  "name": "02d - Sam Altman Collector",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "days",
              "daysInterval": 1
            }
          ]
        }
      },
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  s.id as source_id, \n  s.persona_id, \n  s.url,\n  p.slug as persona_slug, \n  p.name as persona_name\nFROM sources s\nJOIN personas p ON s.persona_id = p.id\nWHERE s.type = 'BLOG'\nAND (s.url LIKE '%samaltman%' OR s.url LIKE '%sama%')\nAND s.status = 'ACTIVE'\nLIMIT 1"
      },
      "name": "Get Altman Source",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [450, 300],
      "credentials": {
        "postgres": {
          "id": "SUPABASE_CREDENTIAL_ID",
          "name": "Supabase PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "url": "https://rss.app/feeds/Tg1vJNdNXOI3RM8A.xml",
        "options": {
          "response": {
            "response": {
              "responseFormat": "text"
            }
          },
          "timeout": 30000
        }
      },
      "name": "Fetch Altman RSS",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst xml = response.data || response.body || '';\nconst sourceInfo = $('Get Altman Source').first().json;\n\nconst links = [];\n\n// Extract links from RSS items\nconst itemMatches = xml.match(/<item>[\\s\\S]*?<\\/item>/gi) || [];\n\nfor (const itemXml of itemMatches.slice(0, 15)) {\n  // Title\n  const titleMatch = itemXml.match(/<title><!\\[CDATA\\[([\\s\\S]*?)\\]\\]><\\/title>/i) ||\n                     itemXml.match(/<title>([^<]+)<\\/title>/i);\n  const title = titleMatch ? titleMatch[1].trim() : 'Untitled';\n  \n  // Link - Sam Altman blog uses blog.samaltman.com\n  const linkMatch = itemXml.match(/<link>([^<]+)<\\/link>/i) ||\n                    itemXml.match(/<guid[^>]*>([^<]+)<\\/guid>/i);\n  let link = linkMatch ? linkMatch[1].trim() : '';\n  \n  // Date\n  const dateMatch = itemXml.match(/<pubDate>([^<]+)<\\/pubDate>/i);\n  let pubDate = null;\n  if (dateMatch) {\n    try {\n      pubDate = new Date(dateMatch[1]).toISOString();\n    } catch (e) {}\n  }\n  \n  if (link && (link.includes('samaltman') || link.includes('sama'))) {\n    // Generate external_id from URL\n    const urlParts = link.replace(/\\/$/, '').split('/');\n    const externalId = (urlParts[urlParts.length - 1] || Date.now().toString())\n      .replace(/[^a-zA-Z0-9-_]/g, '_')\n      .substring(0, 200);\n    \n    links.push({\n      json: {\n        external_id: externalId,\n        external_url: link,\n        title: title,\n        published_at: pubDate,\n        persona_id: sourceInfo.persona_id,\n        source_id: sourceInfo.source_id\n      }\n    });\n  }\n}\n\nreturn links;"
      },
      "name": "Extract Links",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 300]
    },
    {
      "parameters": {
        "url": "={{ $json.external_url }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "text"
            }
          },
          "timeout": 30000
        },
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            },
            {
              "name": "Accept",
              "value": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            }
          ]
        }
      },
      "name": "Fetch Article",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "jsCode": "const allResponses = $input.all();\nconst allLinks = $('Extract Links').all();\nconst results = [];\n\nfor (let i = 0; i < allResponses.length; i++) {\n  const html = allResponses[i].json.data || allResponses[i].json.body || '';\n  const linkInfo = allLinks[i].json;\n  \n  // Skip if blocked or error\n  if (!html || html.length < 500) continue;\n  \n  // Extract article content\n  let content = '';\n  \n  // Sam Altman blog specific patterns\n  const articleMatch = html.match(/<article[^>]*>([\\s\\S]*?)<\\/article>/i) ||\n                       html.match(/<div[^>]*class=\"[^\"]*post-content[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i) ||\n                       html.match(/<div[^>]*class=\"[^\"]*entry-content[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i) ||\n                       html.match(/<div[^>]*class=\"[^\"]*content[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i) ||\n                       html.match(/<main[^>]*>([\\s\\S]*?)<\\/main>/i);\n  \n  if (articleMatch) {\n    content = articleMatch[1];\n  } else {\n    // Fallback: get body\n    const bodyMatch = html.match(/<body[^>]*>([\\s\\S]*?)<\\/body>/i);\n    content = bodyMatch ? bodyMatch[1] : html;\n  }\n  \n  // Clean HTML\n  const cleanContent = content\n    .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n    .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n    .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, '')\n    .replace(/<header[^>]*>[\\s\\S]*?<\\/header>/gi, '')\n    .replace(/<footer[^>]*>[\\s\\S]*?<\\/footer>/gi, '')\n    .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, '')\n    .replace(/<[^>]+>/g, ' ')\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&quot;/g, '\"')\n    .replace(/&#39;/g, \"'\")\n    .replace(/\\s+/g, ' ')\n    .trim();\n  \n  if (cleanContent.length > 200) {\n    results.push({\n      json: {\n        external_id: linkInfo.external_id,\n        external_url: linkInfo.external_url,\n        title: linkInfo.title,\n        raw_content: cleanContent.substring(0, 100000),\n        published_at: linkInfo.published_at,\n        language: 'EN',\n        word_count: cleanContent.split(/\\s+/).length,\n        persona_id: linkInfo.persona_id,\n        source_id: linkInfo.source_id\n      }\n    });\n  }\n}\n\nreturn results.length > 0 ? results : [{ json: { skip: true } }];"
      },
      "name": "Parse Articles",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-skip",
              "leftValue": "={{ $json.skip }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "name": "Has Content?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO documents (\n  id, persona_id, source_id, external_id, external_url,\n  title, raw_content, published_at, language,\n  word_count, status, created_at, updated_at\n) VALUES (\n  gen_random_uuid(),\n  '{{ $json.persona_id }}',\n  '{{ $json.source_id }}',\n  '{{ $json.external_id.replace(/'/g, \"''\") }}',\n  '{{ $json.external_url.replace(/'/g, \"''\") }}',\n  '{{ $json.title.replace(/'/g, \"''\") }}',\n  '{{ $json.raw_content.replace(/'/g, \"''\") }}',\n  {{ $json.published_at ? \"'\" + $json.published_at + \"'\" : \"NULL\" }},\n  '{{ $json.language }}',\n  {{ $json.word_count }},\n  'PENDING_PROCESSING',\n  NOW(),\n  NOW()\n)\nON CONFLICT (source_id, external_id) DO UPDATE SET\n  title = EXCLUDED.title,\n  raw_content = EXCLUDED.raw_content,\n  updated_at = NOW()\nRETURNING id"
      },
      "name": "Save Documents",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1650, 300],
      "credentials": {
        "postgres": {
          "id": "SUPABASE_CREDENTIAL_ID",
          "name": "Supabase PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE sources\nSET \n  last_fetched_at = NOW(),\n  next_fetch_at = NOW() + INTERVAL '1 day',\n  total_fetches = total_fetches + 1,\n  success_fetches = success_fetches + 1,\n  updated_at = NOW()\nWHERE (url LIKE '%samaltman%' OR url LIKE '%sama%') AND type = 'BLOG'"
      },
      "name": "Update Source",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1850, 300],
      "credentials": {
        "postgres": {
          "id": "SUPABASE_CREDENTIAL_ID",
          "name": "Supabase PostgreSQL"
        }
      }
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get Altman Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Altman Source": {
      "main": [
        [
          {
            "node": "Fetch Altman RSS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Altman RSS": {
      "main": [
        [
          {
            "node": "Extract Links",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Links": {
      "main": [
        [
          {
            "node": "Fetch Article",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Article": {
      "main": [
        [
          {
            "node": "Parse Articles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Articles": {
      "main": [
        [
          {
            "node": "Has Content?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Content?": {
      "main": [
        [
          {
            "node": "Save Documents",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Documents": {
      "main": [
        [
          {
            "node": "Update Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "tags": [
    {
      "name": "collector"
    },
    {
      "name": "altman"
    }
  ]
}
